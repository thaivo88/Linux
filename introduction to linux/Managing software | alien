                        Converting between package formats:

The alien program can convert between RPM packages, Debian packages, and tarballs.
alien requires that you have appropriate package manager software installed, both PRM and Debian, to convert between these format.
When converting from a tarball, alien copies the files directly as they had been in the tarball, so alien works only if the original tarball
has files that should be installed off the root (/) direcotry of the system.
                alien [options] [file]
--to-deb : convert to debian
--to-rpm : convert to RPM
--to-tgz : convert to tarball
If you omit the destination format, alien assumes that you want debian package.
If you use a Debian-based system and want to install a tarball but keep a record of the files it contains in your Debian package database:
                alien --install binary-tarball.tar.gz

Say if a tarball was unpacked with bin, lib, sbin but your intent maybe to unpack into /usr or /usr/local
to do so you need to unpack the tarball file and move the file into a new directory called usr then tar the file.
    tar xvfz program.tar.gz         :       uncompress file
    mv program-files usr            :       move all file into a new usr directory
    tar cvfz program.tgz usr        :       compress the usr directory as program.tgz
    rm -r usr                       :       remove usr directory and subdirectory
    alien --to-rpm program.tgz      :       convert tarball into RPM
    


                        Real and imagined package dependency problems

Missing libraries or support programs
One of the most common dependency problems is caused by a missing support package.
Libraries-support code that can be used by many different programs as if it were part of the program itself.

Incompatible libraries or support programs
Even if a library or support program is installed on your system, it may be the wrong version.
Linux library-naming conventions enable you to install multiple versions of a library in case you have programs with competing requirement.

Duplicate files of features
Conflicts arise when one package includes file that are already installed and that belong to another package.
Feature conflicts are usually accompanied by name conflicts.
Mixing packages intended for different distro; because distro may split files across package in different ways.

Mismatched names
RPM and Debian package management systems give names to their packages. These names don't always match across distributions.



                        Workarounds for package dependency problems
            
Forcing the installation, modifying your system to meet the dependency, rebuilding the problem package from source code, and 
finding another version of the problem package.

Forcing the installation:
One approach is to ignore the issue
ignore failed dependencies
        rpm -i apackage.rpm --nodeps
        dpkg -i --ignore-depends=[package]
force installing
        rpm -i apackage.rpm --force
        dpkg -i --force-depends
        dpkg -i --force-conflicts
        
        
        
                        Rebuild package
If the software is recompiled on a system that has different packages, the dependencies will change. Therefore, rebuilding a package
from source code can overcome at least some dependencies. Rebuild a RPM package: you call rpmbuild with the name of the source package
and use --rebuild
        rpmbuild --rebuild packagename-version.src.rpm
Of course, to do this you must have the source RPM for the package.
            
                        Library Principle
If programs use their own libraries we run into these main issue: (Libraries are share due to:)
            -program file is huge; takes up a lot of disk space and consumes a lot of RAM when loading
            -multiple programs use the library, the program-size issue is multiplied; disk space and RAM
            
Shared libraries usually have a .so or .so.[version] extension (like dynamic link libraries .DLL in window)
Static libraries have .a filename extensions. (used by linkers for inclusion in programs when dynamic libraries aren't to be used.)
Shared library changes can be incompatible with some or all programs that use the library. Linux uses library-numbering schemes to 
enable you to keep multiple versions of a library installed at once.                       
                        
                Setting the Path system wide
set the library path : edit the /etc/ld.so.config file
This file consists of a series of lines, each of which lists one directory in which shared library files may be found.

Some distribution use the env-update utility that reads files in /etc/env.d to create the final porm of several /etc configuration files,
including /etc/ld.so.conf.
To change ld.so.conf in distributions that uses this mechanism, you should add or edit files in etc/env.d then type env-update.
Linux refers to the trusted library directories, /lib and /usr/lib. These directories are always on the library path, even if they aren't
listed in ld.so.conf.

After you change your library path, you must use ldconfig to have your programs use the new path.

Correcting library problem:
If you get an error loading shared libraries, make sure it is installed if not install the library.
If the library is installed but the name is different you might want to create a symbolic link.
    example: program may link to biglib.so.5 but your system has biglib.so.5.2 creating a symbolic link will fix this issue.
You may beed to add its directory globally or to LD_LIBRARY_PATH.

